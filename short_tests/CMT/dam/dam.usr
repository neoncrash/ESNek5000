! for shallow water system
! u(:,1,e) is h
! u(:,2,e) is hu
! u(:,3,e) is hv
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      include 'TORO'
      include 'CMTDATA'
      integer  luout(6)
      integer e
      character*26 zefn

      luout(1)=37
      luout(2)=38
      luout(3)=39
      luout(4)=40
      luout(5)=41
      luout(6)=42

      nxyz=nx1*ny1*nz1

      ifxyo = .true.
      if (istep .gt. 1) ifxyo=.false.

! sigh. need settime to bend to my will
      time=time_cmt
      dt=dt_cmt

      umin = glmin(vx,n)
      umax = glmax(vx,n)
!     if (mod(kstep,100).eq.0) then
      if (nio.eq.0) then
         write(6,2)istep,time,umin,' <u<',umax
      endif
!     endif
2     format(i6,1p2e17.8,a4,1p1e17.8)

      if (time_cmt .eq. 0.0.and..not.ifrestart) then
           ! useric kludge to get the discontinuity right at the face
         do e=1,nelt
            iflag=1
            do i=1,nxyz
               if (xm1(i,1,1,e).lt.diaph1) iflag=0
            enddo
            if (iflag .eq.1) then
               ux=dr*ur
               do i=1,nxyz
                  u(i,1,1,1,e)=dr
                  u(i,1,1,2,e)=ux
                  u(i,1,1,3,e)=0.0
               enddo
            else
               ux=dl*ul
               do i=1,nxyz
                  u(i,1,1,1,e)=dl
                  u(i,1,1,2,e)=ux
                  u(i,1,1,3,e)=0.0
               enddo
            endif
         enddo
      endif

      if(ifoutfld.or.istep.eq.1) then
      call compute_primitive_vars

!     if (nio.eq.0)then ! badly parallelized
      write(zefn,'(a16,i6.6,a1,i2.2)') 'profiles/rhoprof',istep,'p',nid
      open(unit=luout(1),file=zefn,form="formatted")
      write(zefn,'(a14,i6.6,a1,i2.2)') 'profiles/uprof',istep,'p',nid
      open(unit=luout(2),file=zefn,form="formatted")
      write(zefn,'(a17,i6.6,a1,i2.2)') 'profiles/viscprof',istep,'p',nid
      open(unit=luout(3),file=zefn,form="formatted")
!     endif
      do e=1,nelt
         l=0
         do k=1,nz1
         do j=1,ny1
         do i=1,nx1
            l=l+1
! profile writer not parallelized correctly
            if (abs(ym1(i,j,k,e)).lt.1.0e-6) then
                  write(luout(1),'(3e25.16)')
     >               xm1(i,j,k,e),u(i,j,k,1,e)
                  write(luout(2),'(3e25.16)')
     >               xm1(i,j,k,e),vx(i,j,k,e)
                  write(luout(6),'(6e25.16)') ! x,visco,diffk,wavevisc,resvisc
!    >               xm1(i,j,k,e),vdiff(i,j,k,e,imu),vdiff(i,j,k,e,inus)
     >               xm1(i,j,k,e),vdiff(i,j,k,e,inus)
!    >              ,t(i,j,k,e,3),res2(i,j,k,e,1),res2(i,j,k,e,2)
     >              ,t(i,j,k,e,3),res2(i,j,k,e,2)
            endif
! profile writer not parallelized correctly
         enddo
         enddo
         enddo
      enddo
      do i=1,3
         close(luout(i))
      enddo

!     call out_fld_nek ! need restart condition
!-----------------------------------------------------------------------
! JH030317
! adding output fields for diagnostic purposes. optional, but perhaps should
! be flagged by values in uservp (Navier-Stokes vs EVM GP vs both)
         call copy(t(1,1,1,1,2),vdiff(1,1,1,1,imu),n)
         call cmult(t(1,1,1,1,2),2.0,n)
         call invcol2(t(1,1,1,1,2),vtrans(1,1,1,1,irho),n)
!                  t(:,:,:,:,3)=wavevisc already
         call copy(t(1,1,1,1,4),vdiff(1,1,1,1,inus),n)
         call copy(t(1,1,1,1,5),res2,n) ! residual viscosity
         call copy(t(1,1,1,1,6),res2(1,1,1,1,2),n) ! raw residual
         if(nio.eq.0) write(37,'(i5,4e25.16)'), istep,err
      endif ! ifoutfld

      return
      end

!-----------------------------------------------------------------------

      subroutine cmt_userEOS(ix,iy,iz,eg)
      include 'SIZE'
      include 'NEKUSE'
      include 'PARALLEL'
      include 'CMTDATA'
      include 'PERFECTGAS'

      integer e,eg
      e=gllel(eg)

      pres=0.5*cpgref*rho**2 ! rho is actually height
      asnd=sqrt(cpgref*rho)  ! cpgref is actually gravitational accel

      return
      end

c-----------------------------------------------------------------------

      subroutine uservp (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'CMTDATA'

      integer e,f,eg
      e = gllel(eg)

      mu=rho*res2(ix,iy,iz,e,1) ! finite c_E;
      nu_s=0.75*mu/rho

      udiff =0.
      lambda=0.0
      utrans=0.

      return
      end

c-----------------------------------------------------------------------

      subroutine userf  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e,f,eg
c     e = gllel(eg)
c     Note: this is an acceleration term, NOT a force!
c     Thus, ffx will subsequently be multiplied by rho(x,t).
      ffx = 0.0
      ffy = 0.0
      ffz = 0.0
      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e,f,eg
c     e = gllel(eg)
      qvol   = 0.0
      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'NEKUSE'
      include 'CMTDATA'
     
      integer f,e,eg
      flux=0.0
      molarmass=molmass
      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'TORO'
      include 'NEKUSE'
      include 'CMTDATA'

      integer e,eg, eqnum
      real r2

      if (x.gt.diaph1) then
         ux=ur
         rho=dr
      else
         ux=ul
         rho=dl
      endif

      uy = 0.
      uz = 0.

      phi = 1.0 ! lol waitaminute
      varsic(1) = rho
      varsic(2) = rho*ux
      varsic(3) = rho*uy

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'
      include 'CMTBCDATA'
      include 'CMTDATA'
      include 'CMTTIMERS'
      include 'PERFECTGAS'

      nbc=0
      do i=1,5 ! get density output
         call add_temp(f2tbc,nbc,1)
      enddo
      igeom=2
      call setup_topo

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'
      include 'TORO'
      include 'CMTBCDATA'
      include 'CMTDATA'

!     call fix_geom

      outflsub=.true.
      IFRESTART=.false.
      IFCNTFILT=.false.
      open(unit=81,file="riemann.inp",form="formatted")
      read (81,*) domlen
      read (81,*) diaph1
      read (81,*) cpgref
      read (81,*) dl
      read (81,*) ul
      read (81,*) dr
      read (81,*) ur
      read (81,*) c_max
      read (81,*) c_sub_e
      close(81)
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'
c
      return
      end
!-----------------------------------------------------------------------
      subroutine cmt_usrflt(rmult)
      include 'SIZE'
      real rmult(nx1)
      real alpfilt
      integer sfilt, kut
      real eta, etac

      call rone(rmult,nx1)

      alpfilt=36.0 ! H&W 5.3

      kut=max((nx1/2),nx1-2)
      kut=nx1/2

      sfilt=8
      etac=real(kut)/real(nx1)
      do i=kut,nx1
         eta=real(i)/real(nx1)
         rmult(i)=exp(-alpfilt*((eta-etac)/(1.0-etac))**sfilt)
      enddo
      return
      end

!--------------------------------------------------------------------   

      subroutine my_full_restart
      include 'SIZE'
      include 'TOTAL'
      character*80 s80(2)

      call blank(s80,2*80)
      s80(1) ='rs6pvort0.f00001'
      s80(2) ='rs6pvort0.f00001'
      call full_restart(s80,2) 

      iosave = iostep           ! Trigger save based on iostep
      call full_restart_save(iosave)

      return
      end
c-----------------------------------------------------------------------

      subroutine evaluate_dealiased_conv_h(e,eq)
! computed as products between primitive variables and conserved variables.
! if you want to write rho u_i u_j as (rho u_i) (rho u_j) (rho^{-1}), this
! is the place to do it
      include  'SIZE'
      include  'SOLN'
      include  'DEALIAS'
      include  'CMTDATA'
      include  'INPUT'
     
      integer  e,eq

      parameter (ldd=lxd*lyd*lzd)
      common /ctmp1/ ju1(ldd),ju2(ldd)!,ur(ldd),us(ldd),ud(ldd),tu(ldd)
      real ju1,ju2

      n=nxd*nyd*nzd

      if (eq .eq. 1) then ! convective flux of mass=rho u_j=U_{j+1}

         do j=1,ndim
            call intp_rstd(convh(1,j),u(1,1,1,eq+j,e),nx1,nxd,if3d,0) !Jhu_j
         enddo

      else ! shallow-water eos is too simple for me to leave it aliased

	 call intp_rstd(ju1,u(1,1,1,irg,e),nx1,nxd,if3d,0) !Jh
         call vsq(ju1,n)
         call cmult(ju1,cpgref,n)
         call cmult(ju1,0.5,n) !1/2 g h^2

! self-advection of gh u_i by u_j

	 call intp_rstd(convh(1,1),u(1,1,1,eq,e),nx1,nxd,if3d,0) ! Jhu_i
	 do j=2,ndim
	    call copy(convh(1,j),convh(1,1),n)
	 enddo
	 call col2(convh(1,1),vxd(1,1,1,e),n)
	 call col2(convh(1,2),vyd(1,1,1,e),n)
	 call add2(convh(1,eq-1),ju1,n)

      endif
     
      return
      end

      subroutine evaluate_aliased_conv_h(e,eq)
! computed as products between primitive variables and conserved variables.
! if you want to write rho u_i u_j as (rho u_i) (rho u_j) (rho^{-1}), this
! is the place to do it
      include  'SIZE'
      include  'SOLN'
      include  'DEALIAS'
      include  'CMTDATA'
      include  'INPUT'

      parameter (ldd=lxd*lyd*lzd)
      common /ctmp1/ ju1(ldd),ju2(ldd)!,ur(ldd),us(ldd),ud(ldd),tu(ldd)
      real ju1,ju2
      integer  e,eq

      n=nx1*ny1*nz1
! copy over dealised, remove interp and just copy
      if (eq .eq. 1) then ! convective flux of mass=rho u_j=U_{j+1}

         do j=1,ndim
            call copy(convh(1,j),u(1,1,1,eq+j,e),n)
         enddo

      else

         call copy(ju1,u(1,1,1,irg,e),n)
         call vsq (ju1,n)
         call cmult(ju1,cpgref,n)
         call cmult(ju1,0.5,n) !1/2 g h^2

! self-advection of gh u_i by u_j

	 call copy(convh(1,1),u(1,1,1,eq,e),n)
	 do j=2,ndim
	    call copy(convh(1,j),convh(1,1),n)
	 enddo
	 call col2(convh(1,1),vxd(1,1,1,e),n)
	 call col2(convh(1,2),vyd(1,1,1,e),n)
	 call add2(convh(1,eq-1),ju1,n)

      endif

      return
      end
C> @}
!-----------------------------------------------------------------------

      subroutine cmt_flow_ics
      include 'SIZE'
      include 'CMTDATA'
      include 'SOLN'

      integer e
      nxyz1 = nx1*ny1*nz1
      n     = nxyz1*lelt*toteq
      if (ifrestart)then
         do e=1,nelt
            call copy(U(1,1,1,2,e),vx(1,1,1,e),nxyz1) 
            call copy(U(1,1,1,3,e),vy(1,1,1,e),nxyz1) 
            call copy(U(1,1,1,1,e),pr(1,1,1,e),nxyz1) 
         enddo
         call copy(tlag(1,1,1,1,1,2),t(1,1,1,1,2),nxyz1*nelt) ! s_{n-1}
         call copy(tlag(1,1,1,1,2,1),t(1,1,1,1,3),nxyz1*nelt) ! s_n
      endif
      call rzero(res1,n)
!     call copy(res2,t(1,1,1,1,5),n) ! art visc hardcoding. old entropy resid
      call rzero(res2,n) ! Actually,...
      return
      end

!-----------------------------------------------------------------------
      subroutine compute_forcing(e,eq_num)
      return
      end
c-----------------------------------------------------------------------
      subroutine cmtusrf(e)
      include 'SIZE'
      include 'NEKUSE'
      include 'CMTDATA'
      include 'TSTEP'
      include 'PARALLEL'

      integer e,eg

      if(istep.eq.1)then
        n = nx1*ny1*nz1*5
        call rzero(usrf,n)
      endif
      eg = lglel(e)
      do k=1,nz1
         do j=1,ny1
            do i=1,nx1
               call NEKASGN(i,j,k,e)
               call userf(i,j,k,eg)
               usrf(i,j,k,2) = FFX
               usrf(i,j,k,3) = FFY
            enddo
         enddo
      enddo

      return
      end 

!-----------------------------------------------------------------------

C> \ingroup vfjac
C> @{
C> flux = \f$\mathscr{A}\f$ dU = \f$\left(\mathscr{A}^{\mbox{NS}}+\mathscr{A}^{\mbox{EVM}}\right) \f$dU 
      subroutine agradu(flux,du,e,eq)
      include 'SIZE'
      include 'CMTDATA'
! Entropy visosity method (EVM)   |  uservp. very error-prone
! mu=mu_s(R_s,|u|+c,h)            |  requires deliberate user attention
! lambda=0 for EVM                |
! nu_s=nu_s(mu_s)                 |
! I need a flag, ifevm, for controlling calls (entropy_residual
! and longitudinal viscous fluxes, mostly due to grad rho) SOMEDAY
!-----------------------------------------------------------------------
! constructive feedback is always welcome
! flux is zero on entry
!-----------------------------------------------------------------------
      integer e, eq
      real flux(nx1*ny1*nz1,ndim),du(nx1*ny1*nz1,toteq,ndim)

! diagnostic
      do i=1,nx1*ny1*nz1
         write(400+nid,'(i5,1x,i2,4e17.8)') i,eq,(du(i,eq,j),j=1,2),
     >   (flux(i,j),j=1,2)
      enddo
! diagnostic

      call fluxj_evm(flux,du,e,eq)

C> @}
      return
      end

      subroutine fluxj_evm(flux,du,e,eq)
! SOLN and CMTDATA are indexed, assuming vdiff has been filled by uservp
! somehow. In serious need of debugging and replacement.
      include 'SIZE'
      include 'PARALLEL'
      include 'INPUT'! TRIAGE?
      include 'SOLN' ! TRIAGE?
      include 'CMTDATA'

      parameter (ldd=lx1*ly1*lz1)
      common /ctmp1/ viscscr(lx1,ly1,lz1) ! I'ma keep this
      real viscscr

      integer e,eq,eq2
      real flux(nx1*ny1*nz1,ndim),du(nx1*ny1*nz1,toteq,ndim)

      n=nx1*ny1*nz1

! diffusion due to grad rho
      if (eq .eq. 1) then
         do j=1,ndim ! flux+= viscscr*nu_s*grad (rho)
            call addcol3(flux(1,j),vdiff(1,1,1,e,inus),du(1,1,j),n)
!@ diagnostic
            do i=1,n
               write(500+nid,*) j,flux(i,j)
            enddo
!@ diagnostic
         enddo
      else ! parabolic, but with different viscosity than height
         do j=1,ndim ! flux+= viscscr*nu_s*grad (rho)
            call addcol3(flux(1,j),vdiff(1,1,1,e,imu),du(1,2,j),n)
         enddo

      endif ! eq==1?

      return
      end

!-----------------------------------------------------------------------

      subroutine compute_transport_props
! get vdiff props
! viscosity in imu
! second viscosity in ilam; second viscosity is usually -2/3mu
! but we refuse to assume Stokes' hypothesis for the user
! second viscosity=0 in the EVM for Euler gas dynamics
! thermal conductivity in iknd;
! mass diffusivity for EVM in inus
! via nekasgn
      include 'SIZE'
      include 'PARALLEL'
      include 'NEKUSE'
      include 'SOLN'
      include 'CMTDATA'

      integer   e

      do e=1,nelt
         ieg=lglel(e)
         do k=1,nz1
         do j=1,ny1
         do i=1,nx1
            call nekasgn(i,j,k,e)
            call cmtasgn(i,j,k,e)
            call uservp(i,j,k,ieg)
            vdiff(i,j,k,e,imu)  = mu   ! NEKUSE
            vdiff(i,j,k,e,inus) = nu_s! CMTDATA
         enddo
         enddo
         enddo
      enddo

      return
      end

!-----------------------------------------------------------------------

      subroutine setup_cmt_param
      INCLUDE 'SIZE'
      INCLUDE 'INPUT'
      INCLUDE 'CMTDATA'
      INCLUDE 'CMTBCDATA'

      return
      end

c------------------------------------------------------------------------
C> @file driver3_cmt.f routines for primitive variables, usr-file interfaces
C> and properties

C> Compute primitive variables (velocity, thermodynamic state) from 
C> conserved unknowns U
      subroutine compute_primitive_vars
      include 'SIZE'
      include 'INPUT'
      include 'GEOM'
      include 'CMTDATA'
      include 'SOLN'
      include 'DEALIAS' ! until we are comfortable with setup_convect

      parameter (lxyz=lx1*ly1*lz1)
      common /ctmp1/ energy(lx1,ly1,lz1),scr(lx1,ly1,lz1)
      integer e, eq

      nxyz= nx1*ny1*nz1
      ntot=nxyz*nelt

      do e=1,nelt
         call invcol3(vx(1,1,1,e),u(1,1,1,irpu,e),u(1,1,1,irg,e),nxyz)
         call invcol3(vy(1,1,1,e),u(1,1,1,irpv,e),u(1,1,1,irg,e),nxyz)
! don't forget to get height where it belongs
         call copy(vtrans(1,1,1,e,irho),u(1,1,1,irg,e),nxyz)
         call tdstate(e)
      enddo

! setup_convect has the desired effect
! if IFPART=F
! if IFCHAR=F
! if IFCONS=T
! if igeom .ne. 1
! if param(99) .ge. 0
!-----------------------------------------------------------------------
!     call setup_convect(0)
!-----------------------------------------------------------------------
! to make life easier until we master this stuff and harmonize even better with nek,
! I'm including 'DEALIAS' and calling set_convect_cons here
      if (nxd.gt.nx1) then
         call set_convect_cons (vxd,vyd,vzd,vx,vy,vz)
      else
         call copy(vxd,vx,ntot) 
         call copy(vyd,vy,ntot) 
      endif

      return
      end
!-----------------------------------------------------------------------

C> Compute "state" for element e. Just depends on height and g=cpgref for shallow water
C> usr file.
      subroutine tdstate(e)
c compute the gas properties. We will have option to add real gas models
c We have perfect gas law. Cvg is stored full field
      include 'SIZE'
      include 'CMTDATA'
      include 'SOLN'
      include 'PARALLEL'
      include 'NEKUSE'
      integer   e,eg

      eg = lglel(e)
      do k=1,nz1
      do j=1,ny1
      do i=1,nx1
         call nekasgn(i,j,k,e)
         call cmtasgn(i,j,k,e)
         call cmt_userEOS(i,j,k,eg)
         pr(i,j,k,e)     = pres
         csound(i,j,k,e) = asnd
      enddo
      enddo
      enddo

      return
      end

c-----------------------------------------------------------------------

      subroutine cmtasgn (ix,iy,iz,e)
      include 'SIZE'
      include 'SOLN'
      include 'CMTDATA'
      include 'NEKUSE'

      integer e,eqnum

      do eqnum=1,toteq
         varsic(eqnum)=u(ix,iy,iz,eqnum,e)  
      enddo
      rho  = vtrans(ix,iy,iz,e,irho) ! actually height*rho
      pres = pr    (ix,iy,iz,e)
      cp   = cpgref ! gravitational constant
      asnd = csound(ix,iy,iz,e)
      mu     = vdiff(ix,iy,iz,e,imu)
      udiff  = vdiff(ix,iy,iz,e,iknd)
! MAKE SURE WE''RE NOT USING UTRANS FOR ANYTHING IN pre-v16 code!!
      lambda = vdiff(ix,iy,iz,e,ilam)

      return
      end

!-----------------------------------------------------------------------

      subroutine cmt_ics
! overlaps with setics. -DCMT will require IFDG as well
      include 'SIZE'
      include 'SOLN'
      include 'GEOM'
      include 'PARALLEL'
      include 'CMTDATA'
      include 'NEKUSE'
      nxyz2=nx2*ny2*nz2       ! Initialize all fields:
      ntot2=nxyz2*nelv
      nxyz1=nx1*ny1*nz1
      ntott=nelt*nxyz1
      ntotv=nelv*nxyz1
      ltott=lelt*nxyz1
      ntotcv=lelt*nxyz1*toteq
      call rzero(phig,ltott)
      call rzero(csound,ltott)
      call rzero(vtrans,ltott*ldimt1)
      call rzero(vdiff ,ltott*ldimt1)
      call rzero(u,ntotcv)
      call cmtuic
      if(ifrestart) call my_full_restart !  Check restart files. soon...

C print min values
      xxmax = glmin(xm1,ntott)
      yymax = glmin(ym1,ntott)
      zzmax = glmin(zm1,ntott)

      vxmax = glmin(vx,ntotv)
      vymax = glmin(vy,ntotv)
      vzmax = glmin(vz,ntotv)
      prmax = glmin(pr,ntot2)

      ntot = nxyz1*nelt
      ttmax = glmin(t ,ntott)

      if (nio.eq.0) then
         write(6,19) xxmax,yymax,zzmax
   19    format('Cxyz min  ',5g25.18)
      endif
      if (nio.eq.0) then
         write(6,20) vxmax,vymax,vzmax,prmax,ttmax
   20    format('Cuvwpt min',5g25.18)
      endif

c print max values
      xxmax = glmax(xm1,ntott)
      yymax = glmax(ym1,ntott)
      zzmax = glmax(zm1,ntott)

      vxmax = glmax(vx,ntotv)
      vymax = glmax(vy,ntotv)
      vzmax = glmax(vz,ntotv)
      prmax = glmax(pr,ntot2)

      ntot = nxyz1*nelt
      ttmax = glmax(t ,ntott)

      if (nio.eq.0) then
         write(6,16) xxmax,yymax,zzmax
   16    format('Cxyz max  ',5g25.18)
      endif

      if (nio.eq.0) then
         write(6,17) vxmax,vymax,vzmax,prmax,ttmax
   17    format('Cuvwpt max',5g25.18)
      endif

c     ! save velocity on fine mesh for dealiasing
!     call setup_convect(2) ! check what this does again. might be a good
!                           ! idea, or it might be counterproductive
      if(nio.eq.0) then
        write(6,*) 'done :: set initial conditions, CMT-nek'
        write(6,*) ' '
      endif
      return
      end

!-----------------------------------------------------------------------

      subroutine cmtuic
! overlaps with setics. -DCMT will require IFDG as well
      include 'SIZE'
      include 'SOLN'
      include 'PARALLEL'
      include 'CMTDATA'
      include 'NEKUSE'
      integer e,eg
      do e=1,nelt
         eg = lglel(e)
         do k=1,nz1
         do j=1,ny1
         do i=1,nx1           
            call nekasgn (i,j,k,e)
            call cmtasgn (i,j,k,e)
            call useric  (i,j,k,eg)
            vx(i,j,k,e) = ux
            vy(i,j,k,e) = uy
            vtrans(i,j,k,e,irho)  = rho
            phig(i,j,k,e)  = phi
!           pr(i,j,k,e)    = pres
            u(i,j,k,irg,e) = rho
            u(i,j,k,irpu,e)= rho*ux
            u(i,j,k,irpv,e)= rho*uy
            vdiff(i,j,k,e,imu) = mu
            vdiff(i,j,k,e,iknd)= udiff
            vdiff(i,j,k,e,ilam)= lambda
         enddo
         enddo
         enddo
      enddo
      return
      end

      subroutine compute_entropy(s)
! computes entropy at istep and pushes the stack down for previous
! steps needed to compute ds/dt via finite difference (for now).
! hardcoded for Burgers equation. More later when folded into CMT-nek
! for Burgers, s=energy=1/2 U^2
      include 'SIZE'
      include 'TOTAL'  ! tlag is lurking. be careful
      include 'CMTDATA'
! I've always seen lorder=3, but I still need three steps
!          s(:,               1,       1)  ! entropy at current step
!          s(:,               2,       1)  ! entropy at step n-1
!          s(:,               1,       2)  ! entropy at step n-2
      real s(lx1*ly1*lz1*lelt,lorder-1,*)
      real ntol
      integer e
      data icalld /0/
      save icalld

      n=nx1*ny1*nz1
      ntot=n*nelt
      ntol=1.0e-10

      if (icalld .eq. 0) then
         write(6,*) 'zeroing out entropy stack',istep
         icalld=1
         call rzero(s,ntot)
         call rzero(s(1,1,2),ntot) ! s_{n-1}
         call rzero(s(1,2,1),ntot) ! s_n
      endif

! compute the current entropy. This actually needs to go back in the
! usr file because it's EOS-dependent
      rgam=rgasref/(gmaref-1.0)
      do i=1,ntot
         s(i,1,1)=0.5*(vtrans(i,1,1,1,irho)*
     >           (vx(i,1,1,1)**2+vy(i,1,1,1)**2)+cpgref*
     >           vtrans(i,1,1,1,irho)**2)
      enddo

      if (stage .eq. 1) then
! push the stack
         call copy(s(1,1,2),s(1,2,1),ntot) ! s_{n-1}=s_n
         call copy(s(1,2,1),s(1,1,1),ntot) ! fill s_n
      endif

      return
      end

!-----------------------------------------------------------------------
! This may not actually stay in the usr file after further refactoring
C> \ingroup bcond
C> @{
C> Determining IGU contribution to boundary flux. 0 for artificial
C> viscosity, and strictly interior for physical viscosity.
      subroutine bcflux(flux,agradu,qminus)
! Need proper indexing and nekasgn & cmtasgn calls
      include 'SIZE'
      include 'INPUT'
      include 'DG'
!     include 'NEKUSE'
      include 'TSTEP' ! wait how do we know what ifield is?
      integer e,eq,f
      real flux  (nx1*nz1,2*ndim,nelt,toteq)
      real agradu(nx1*nz1,2*ndim,nelt,toteq)
!     real qminus(nx1*nz1,2*ndim,nelt,nqq) ! include CMTDATA?
      real qminus(*) ! 'scuse me. comin' through
      common /nekcb/ cb
      character*3 cb

      nfaces=2*ndim
      nxz=nx1*nz1
      ifield=1

      do e=1,nelt
         do f=1,nfaces
            if (cbc(f, e, ifield).ne.'E  '.and.
     >          cbc(f, e, ifield).ne.'P  ') then ! cbc bndy
               cb=cbc(f,e,ifield)
               if (cb .eq. 'I  ') then ! NEUMANN CONDITIONS GO HERE
                  call rzero(flux(1,f,e,1),nxz)
                  do eq=2,ndim+1
                     call copy(flux(1,f,e,eq),agradu(1,f,e,eq),nxz)
                  enddo
                  call rzero(flux(1,f,e,toteq),nxz)
!                 cbu=cb
!                 do eq=1,toteq
!                    call userflux(flux(1,f,e,eq)) ! replace this with userbc
!                 enddo
               else  ! if (cb .eq. 'SYM') then ! NEED PHYSICAL VISC TEST
! JH031617 But this code block basically guarantees that artificial viscosity
!          does not contribute to viscous fluxes at boundaries.
                  do eq=1,toteq
                     call rzero(flux(1,f,e,eq),nxz)
                  enddo
               endif
            endif
         enddo
      enddo

C> @}
      return
      end

!-----------------------------------------------------------------------

      subroutine reflect_rind(nvar,f,e,facew,wbc)
      include 'SIZE'
      include 'CMTBCDATA'
      include 'CMTDATA'
      include 'GEOM'
      include 'INPUT'
      include 'PARALLEL'
      include 'DG'
      include 'MASS'
      include 'TSTEP'
      integer  f,e
! JH091614 facew now has intent(inout)...
! JH031315 not anymore. nobody changes qminus here. that's dumb
      real facew(nx1*nz1,2*ndim,nelt,nvar)
      real wbc(nx1*nz1,2*ndim,nelt,nvar)
      integer i, nxz, fdim
      real nx,ny,nz,rl,ul,vl,wl,pl,fs
      parameter (lfd1=lxd*lzd,lfc1=lx1*lz1)

      nxz=nx1*nz1
      nxzd=nxd*nzd
      fdim=ndim-1
      ieg=lglel(e)
      ifield=1

! I know this says slipwall, but to the inviscid terms all walls are
! slip. or something.
      call facind(i0,i1,j0,j1,k0,k1,nx1,ny1,nz1,f)    
      do l=1,nxz
         nx = unx(l,1,f,e)
         ny = uny(l,1,f,e)
         nz = unz(l,1,f,e)
         rl = facew(l,f,e,irho)
         rr = rl
         ul = facew(l,f,e,iux)
         vl = facew(l,f,e,iuy)
         wl = facew(l,f,e,iuz)
         fs = 0.0 ! no moving grid for awhile, and it will not look anything
                  ! like RocFlu

! JH111516 Mirror a la' Dolejsi & Feistauer (2015) section 8.3.1.2
! JH021717 This is for inviscid fluxes, which are produced by the Riemann
!          solver. Presently, this is AUSM, which acts on primitive variables
!          as-coded. Still, it always makes sense to form UBC, so we do so
!          here even though it is different for viscous BC
         udotn = ul*nx+vl*ny+wl*nz
         ur = ul-2.0*udotn*nx
         vr = vl-2.0*udotn*ny
         wr = wl-2.0*udotn*nz
         wbc(l,f,e,irho)= rr
         wbc(l,f,e,iux) = ur
         wbc(l,f,e,iuy) = vr
         wbc(l,f,e,iuz) = wr
         wbc(l,f,e,ipr) = facew(l,f,e,ipr)
         wbc(l,f,e,isnd)= facew(l,f,e,isnd)
!        wbc(l,f,e,iph) = facew(l,f,e,iph)
         wbc(l,f,e,iu1)= facew(l,f,e,iu1)
         wbc(l,f,e,iu2)= rr*ur
         wbc(l,f,e,iu3)= rr*vr
      enddo

      return
      end


C> @file wall_bc.f Dirichlet states for wall boundary conditions
! FUN FACT: Did you know that bdry.f has a subroutine called
!           BCNEUSC
      subroutine wallbc2(nstate,f,e,facew,wbc)
! DIRICHLET WALL CONDITIONS BECAUSE I DONT KNOW HOW TO INDEX
! UNX in userbc with volume indices instead of face indices
      INCLUDE 'SIZE'
      INCLUDE 'INPUT'
      INCLUDE 'TSTEP'
      include 'SOLN'
      include 'NEKUSE'
      include 'PARALLEL'
      include 'CMTBCDATA'
      include 'CMTDATA'

      integer nstate,f,e
      real    facew(nx1*nz1,2*ndim,nelt,nstate)
      real    wbc(nx1*nz1,2*ndim,nelt,nstate) 
      common /nekcb/ cb
      character*3 cb

      tol=1.0e-10
! JH112116
! rind state for inviscid fluxes is different from viscous fluxes? not
! sure what the right thing to do is.
! JH031617 Collis (CTR 2002-ish), Hartmann & Houston (2006-8) probably BR
!          and Dolejsi and Feistatuer (2015) (check that)
!          all say YES, inviscid rind and viscous rind are different.
      call facind(i0,i1,j0,j1,k0,k1,nx1,ny1,nz1,f)    
      ieg=lglel(e)
      l=0
      do iz=k0,k1
      do iy=j0,j1
      do ix=i0,i1
         call nekasgn(ix,iy,iz,e)
         call cmtasgn(ix,iy,iz,e)
         call userbc (ix,iy,iz,f,ieg)
         l=l+1

! JH031617 For now, artificial viscosity does not directly contribute to
!          boundary fluxes at all. This means dU=0 for IGTU and gradU is
!          strictly interior for IGU
            do m=1,nqq ! TEST FOR vDIFF OUTSIDE WHAT THE EHLLO IS WRONG WITH YOU
               wbc(l,f,e,m)=facew(l,f,e,m)
            enddo

      enddo
      enddo
      enddo

      return
      end

!--------------------------------------------------------------------

      subroutine inflow_rflu(nvar,f,e,facew,wbc)
      include 'SIZE'
      include 'INPUT'
      include 'NEKUSE'
      include 'CMTDATA'
      include 'GEOM'
      include 'PARALLEL'
      include 'DG'
      include 'PERFECTGAS'

      integer f,e,fdim ! intent(in)
      integer i,bcOptType
      real facew(nx1*nz1,2*ldim,nelt,nvar) ! intent(in)
      real wbc  (nx1*nz1,2*ldim,nelt,nvar)   ! intent(out)
      real snx,sny,snz,rhou,rhov,rhow,pl,rhob,rhoub,rhovb,rhowb
     >     ,rhoeb, mach

      nxz=nx1*nz1
      nxzd=nxd*nzd
      fdim=ndim-1
      ieg=lglel(e)

      call facind(i0,i1,j0,j1,k0,k1,nx1,ny1,nz1,f)    
      l=0
      do iz=k0,k1
      do iy=j0,j1
      do ix=i0,i1
         call nekasgn(ix,iy,iz,e)
         call cmtasgn(ix,iy,iz,e)
         call userbc (ix,iy,iz,f,ieg) ! get molarmass asnd phi t0in p0in cp cv
c                                     !     ux,uy,uz
         l=l+1

         bcOptType=0
         snx  = unx(l,1,f,e)
         sny  = uny(l,1,f,e)

         rho  = facew(l,f,e,iu1)/facew(l,f,e,iph)
         rhou = facew(l,f,e,iu2)/facew(l,f,e,iph)
         rhov = facew(l,f,e,iu3)/facew(l,f,e,iph)
         rhow = facew(l,f,e,iu4)/facew(l,f,e,iph)
         rhoe = facew(l,f,e,iu5)/facew(l,f,e,iph)

         if (if3d) then
            mach = sqrt(ux**2+uy**2+uz**2)/asnd
            snz  = unz(l,1,f,e)
         else
            mach = sqrt(ux**2+uy**2)/asnd
            snz=0.0
         endif
         if (mach.lt.1.0) bcOptType=1

!        call BcondInflowPerf(bcOptType,0,p0in,t0in,ux,uy,uz
!    >                       ,mach,snx,sny,snz,cp
!    >                       ,molarmass,rho,rhou,rhov,rhow,rhob,rhoub
!    >                       ,rhovb,rhowb,rhoeb,pres,asnd,temp)
         
         wbc(l,f,e,irho) = rhob
         wbc(l,f,e,iux)  = ux
         wbc(l,f,e,iuy)  = uy
         wbc(l,f,e,iuz)  = uz
         wbc(l,f,e,isnd) = asnd ! overwritten by Bcond
         wbc(l,f,e,ipr)  = pres ! overwritten by Bcond
         wbc(l,f,e,ithm) = temp ! overwritten by Bcond
         wbc(l,f,e,icpf) = rho*cp
         wbc(l,f,e,icvf) = rho*cv
         wbc(l,f,e,iu1)  = rhob*phi
         wbc(l,f,e,iu2)  = rhoub*phi
         wbc(l,f,e,iu3)  = rhovb*phi
         wbc(l,f,e,iu4)  = rhowb*phi
         wbc(l,f,e,iu5)  = rhoeb*phi
      enddo
      enddo
      enddo

      return
      end

!--------------------------------------------------------------------

      subroutine inflow_inviscid(nvar,f,e,facew,wbc)
! JH021717 more conventional Dolejsi & Feistauer (2015),
!          Hartmann & Houston (2006) type boundary conditions
!          Emergency fallback if Holmes just doesn't play nice with DG
      include 'SIZE'
!     include 'TSTEP' ! diagnostics
      include 'INPUT'
      include 'NEKUSE'
      include 'CMTDATA'
      include 'GEOM'
      include 'PARALLEL'
      include 'DG'
      include 'PERFECTGAS'

      integer f,e,fdim ! intent(in)
      integer i
      real facew(nx1*nz1,2*ldim,nelt,nvar) ! intent(in)
      real wbc  (nx1*nz1,2*ldim,nelt,nvar)   ! intent(out)
      real snx,sny,snz,rhou,rhov,rhow,pl,rhob,rhoub,rhovb,rhowb
     >     ,rhoeb, mach

      nxz=nx1*nz1
      nxzd=nxd*nzd
      fdim=ndim-1
      ieg=lglel(e)

      call facind(i0,i1,j0,j1,k0,k1,nx1,ny1,nz1,f)    
      l=0
      do iz=k0,k1
      do iy=j0,j1
      do ix=i0,i1
         call nekasgn(ix,iy,iz,e)
         call cmtasgn(ix,iy,iz,e)
         call userbc (ix,iy,iz,f,ieg) ! get molarmass asnd phi t0in p0in cp cv
c                                     !     ux,uy,uz
         l=l+1
         wbc(l,f,e,irho) = rho  ! Dirichlet, userbc
         wbc(l,f,e,iux)  = ux   ! Dirichlet, userbc
         wbc(l,f,e,iuy)  = uy   ! Dirichlet, userbc
         wbc(l,f,e,iuz)  = uz   ! Dirichlet, userbc
         wbc(l,f,e,iph)  = phi  ! Dirichlet, userbc
         rhob   = rho*phi
         rhoub  = rho*ux*phi
         rhovb  = rho*uy*phi
         rhowb  = rho*uz*phi
         wbc(l,f,e,iu1)  = rhob
         wbc(l,f,e,iu2)  = rhoub
         wbc(l,f,e,iu3)  = rhovb
         wbc(l,f,e,iu4)  = rhowb

         if (if3d) then ! shouldn't this be normal Mach number?
            mach = sqrt(ux**2+uy**2+uz**2)/asnd
            snz  = unz(l,1,f,e)
         else
            mach = sqrt(ux**2+uy**2)/asnd
            snz=0.0
         endif

         snx  = unx(l,1,f,e)
         sny  = uny(l,1,f,e)

         if (mach.lt.1.0) then

            pres  = facew(l,f,e,ipr) ! extrapolated, overwritten
            temp = pres/rho/(cp-cv) ! definitely too perfect!
            wbc(l,f,e,ipr)  = pres
            wbc(l,f,e,isnd) = sqrt(cp/cv*pres/rho) ! too perfect?
            wbc(l,f,e,ithm) = temp      ! definitely too perfect!
            wbc(l,f,e,icpf) = rho*cp ! NEED EOS WITH TEMP Dirichlet, userbc
            wbc(l,f,e,icvf) = rho*cv ! NEED EOS WITH TEMP Dirichlet, userbc

         else ! supersonic inflow

            wbc(l,f,e,ipr)  = pres
            wbc(l,f,e,isnd) = asnd
            wbc(l,f,e,ithm) = temp
            wbc(l,f,e,icpf) = rho*cp
            wbc(l,f,e,icvf) = rho*cv

         endif

! find a smarter way of doing this. fold it into usr file if you must
         wbc(l,f,e,iu5)  = phi*rho*cv*temp+0.5/rhob*(rhoub**2+rhovb**2+
     >                                               rhowb**2)

      enddo
      enddo
      enddo

      return
      end

      subroutine outflow_rflu(nvar,f,e,facew,wbc)
      include 'SIZE'
      include 'NEKUSE'
      include 'CMTDATA'
      include 'CMTBCDATA'
      include 'INPUT'
      include 'GEOM'
      include 'PARALLEL'
      include 'DG'

      integer i,bcOpt
      integer  f,e,fdim
      real facew(nx1*nz1,2*ldim,nelt,nvar)
      real wbc(nx1*nz1,2*ldim,nelt,nvar)
      real sxn,syn,szn,rhou,rhov,rhow,pl,rhob,rhoub,rhovb,rhowb,rhoeb

      nxz=nx1*nz1
      nxzd=nxd*nzd
      fdim=ndim-1
      ieg=lglel(e)

      call facind(i0,i1,j0,j1,k0,k1,nx1,ny1,nz1,f)    
      l=0
      do iz=k0,k1
      do iy=j0,j1
      do ix=i0,i1
         call nekasgn(ix,iy,iz,e)     ! gives us phi- and rho-
         call cmtasgn(ix,iy,iz,e)
         call userbc (ix,iy,iz,f,ieg) ! just for molarmass, and
                                      ! pres
         l=l+1
         sxn = unx(l,1,f,e)
         syn = uny(l,1,f,e)
         szn = unz(l,1,f,e)
         rhou= facew(l,f,e,iu2)/phi
         rhov= facew(l,f,e,iu3)/phi
         rhow= facew(l,f,e,iu4)/phi
         rhoe= facew(l,f,e,iu5)/phi
         pl= facew(l,f,e,ipr) ! P- here
         wbc(l,f,e,icpf)=facew(l,f,e,icpf)
         wbc(l,f,e,icvf)=facew(l,f,e,icvf)
         cp=facew(l,f,e,icpf)/rho
         cv=facew(l,f,e,icvf)/rho
c        fs = 0.0
         if(outflsub)then
            pres= pinfty
         else
            pres= facew(l,f,e,ipr)
         endif
!        call BcondOutflowPerf(1,pres,sxn,syn,szn,cp,molarmass,
!    >                         rho,rhou,rhov,rhow,rhoe,pl,
!    >                         rhob,rhoub,rhovb,rhowb,rhoeb )
         wbc(l,f,e,irho)=rhob
         wbc(l,f,e,iux)=rhoub/rhob
         wbc(l,f,e,iuy)=rhovb/rhob
         wbc(l,f,e,iuz)=rhowb/rhob
! dammit fix this. tdstate to the rescue?
         wbc(l,f,e,ithm)=(rhoeb-0.5*(rhoub**2+rhovb**2+rhowb**2)/rhob)/
     >                   cv
! dammit fix that
         wbc(l,f,e,iu1)=rhob*phi
         wbc(l,f,e,iu2)=rhoub*phi
         wbc(l,f,e,iu3)=rhovb*phi
         wbc(l,f,e,iu4)=rhowb*phi
         wbc(l,f,e,iu5)=rhoeb*phi
         wbc(l,f,e,iph)=phi
         wbc(l,f,e,ipr)=pres
! dammit fix this. tdstate to the rescue?
         wbc(l,f,e,isnd)=sqrt(cp/cv*pres/rho)
! dammit fix that
      enddo
      enddo
      enddo

      return
      end

      subroutine InviscidFlux(wminus,wplus,flux,nstate,nflux)
!-------------------------------------------------------------------------------
! JH091514 A fading copy of RFLU_ModAUSM.F90 from RocFlu
!-------------------------------------------------------------------------------

      include 'SIZE'
      include 'INPUT' ! do we need this?
      include 'GEOM' ! for unx
      include 'CMTDATA' ! do we need this without outflsub?
      include 'TSTEP' ! for ifield?
      include 'DG'

! ==============================================================================
! Arguments
! ==============================================================================
      integer nstate,nflux
      real wminus(nx1*nz1,2*ndim,nelt,nstate),
     >     wplus(nx1*nz1,2*ndim,nelt,nstate),
     >     flux(nx1*nz1,2*ndim,nelt,nflux)

! ==============================================================================
! Locals
! ==============================================================================

      integer e,f,fdim,i,k,nxz,nface
      parameter (lfd=lxd*lzd)
! JH111815 legacy rocflu names.
!
! nx,ny,nz : outward facing unit normal components
! fs       : face speed. zero until we have moving grid
! jaco_c   : fdim-D GLL grid Jacobian
! nm       : jaco_c, fine grid
!
! State on the interior (-, "left") side of the face
! rl       : height
! ul,vl,wl : velocity
! al       : sound speed
! State on the exterior (+, "right") side of the face
! rr       : height
! ur,vr,wr : velocity
! ar       : sound speed

      COMMON /SCRNS/ nx(lfd), ny(lfd), nz(lfd), rl(lfd), ul(lfd),
     >               vl(lfd), al(lfd), rr(lfd), ur(lfd), vr(lfd),
     >               ar(lfd),fs(lfd),
     >               jaco_f(lfd),flx(lfd,toteq),jaco_c(lx1*lz1)
      real nx, ny, nz, rl, ul, vl, al, rr, ur, vr, 
     >                ar,fs,jaco_f,flx,jaco_c

!     REAL vf(3)
      real nTol
      character*132 deathmessage
      common /nekcb/ cb
      character*3 cb

      nTol = 1.0E-14

      fdim=ndim-1
      nface = 2*ndim
      nxz   = nx1*nz1
      nxzd  = nxd*nzd
      ifield= 1 ! You need to figure out the best way of dealing with
                ! this variable

      do e=1,nelt
      do f=1,nface

! JH021717 Finally corrected BC wrongheadedness. Riemann solver handles
!          all fluxes with even the slightest Dirichlet interpretation,
!          and BC fill wplus sanely for the Riemann solver to provide
!          a good flux for weak BC.
! JH111715 now with dealiased surface integrals. I am too lazy to write
!          something better

! diagnostic
!        if (cbc(f,e,ifield).eq.'v  '.or.cbc(f,e,ifield).eq.'V  ')then
!        if (istep .eq. 1000) then
!           do i=1,nxz
!              write(10+istep,'(2i3,a3,8e15.7)') e,f,cbc(f,e,ifield),
!    .         wminus(i,f,e,irho),wplus(i,f,e,irho),
!    .      wminus(i,f,e,iux), wplus(i,f,e,iux), wminus(i,f,e,iuy),
!    .      wplus(i,f,e,iuy),wminus(i,f,e,isnd),wplus(i,f,e,isnd)
!           enddo
!        endif
! diagnostic

         if (nxd.gt.nx1) then
            call map_faced(nx,unx(1,1,f,e),nx1,nxd,fdim,0)
            call map_faced(ny,uny(1,1,f,e),nx1,nxd,fdim,0)
            call map_faced(nz,unz(1,1,f,e),nx1,nxd,fdim,0)

            call map_faced(rl,wminus(1,f,e,irho),nx1,nxd,fdim,0)
            call map_faced(ul,wminus(1,f,e,iux),nx1,nxd,fdim,0)
            call map_faced(vl,wminus(1,f,e,iuy),nx1,nxd,fdim,0)
            call map_faced(al,wminus(1,f,e,isnd),nx1,nxd,fdim,0)

            call map_faced(rr,wplus(1,f,e,irho),nx1,nxd,fdim,0)
            call map_faced(ur,wplus(1,f,e,iux),nx1,nxd,fdim,0)
            call map_faced(vr,wplus(1,f,e,iuy),nx1,nxd,fdim,0)
            call map_faced(ar,wplus(1,f,e,isnd),nx1,nxd,fdim,0)

            call invcol3(jaco_c,area(1,1,f,e),wghtc,nxz)
            call map_faced(jaco_f,jaco_c,nx1,nxd,fdim,0) 
            call col2(jaco_f,wghtf,nxzd)
         else

            call copy(nx,unx(1,1,f,e),nxz)
            call copy(ny,uny(1,1,f,e),nxz)
            call copy(nz,unz(1,1,f,e),nxz)

            call copy(rl,wminus(1,f,e,irho),nxz)
            call copy(ul,wminus(1,f,e,iux),nxz)
            call copy(vl,wminus(1,f,e,iuy),nxz)
            call copy(al,wminus(1,f,e,isnd),nxz)

            call copy(rr,wplus(1,f,e,irho),nxz)
            call copy(ur,wplus(1,f,e,iux),nxz)
            call copy(vr,wplus(1,f,e,iuy),nxz)
            call copy(ar,wplus(1,f,e,isnd),nxz)

            call copy(jaco_f,area(1,1,f,e),nxz) 
         endif
         call rzero(fs,nxzd) ! moving grid stuff later

         call LF2D_FluxFunction(nxzd,nx,ny,nz,jaco_f,rl,ul,vl,
     >                          al,rr,ur,vr,ar,flx)

         if (nxd.gt.nx1) then
            do j=1,toteq
               call map_faced(flux(1,f,e,j),flx(1,j),nx1,nxd,fdim,1)
            enddo
         else
            do j=1,toteq
               call copy(flux(1,f,e,j),flx(1,j),nxz)
            enddo
         endif

      enddo
      enddo

      end

!-------------------------------------------------------------------------------
      subroutine LF2D_FluxFunction(ntot,nx,ny,nz,area,hl,ul,vl,
     >                          al,hr,ur,vr,ar,flx)
! Lax-Friedrichs fluxes, hardcoded for shallow water
      include 'SIZE' ! just for toteq
      real nx(ntot),ny(ntot),nz(ntot),area(ntot),hl(ntot),ul(ntot),
     >     vl(ntot),al(ntot),hr(ntot),ur(ntot),vr(ntot),ar(ntot),
     >     flx(ntot,toteq)
      real mlx,mrx,mly,mry

      do i=1,ntot
! Li's dgf3.f had central fluxes of each component, then dot with normal
         mlx=hl(i)*ul(i)
         mrx=hr(i)*ur(i)
         mly=hl(i)*vl(i)
         mry=hr(i)*vr(i)
         cfx=0.5*(mlx+mrx)*area(i)
         cfy=0.5*(mly+mry)*area(i)
         flx(i,1)=cfx*nx(i)+cfy*ny(i)
         fm1xl=mlx*ul(i)+0.5*hl(i)**2
         fm1yl=mlx*vl(i)
         fm2xl=mly*ul(i)
         fm2yl=mly*vl(i)+0.5*hl(i)**2
         fm1xr=mrx*ur(i)+0.5*hr(i)**2
         fm1yr=mrx*vr(i)
         fm2xr=mry*ur(i)
         fm2yr=mry*vr(i)+0.5*hr(i)**2

         cfx=0.5*(fm1xl+fm1xr)*area(i)
         cfy=0.5*(fm1yl+fm1yr)*area(i)
         flx(i,2)=cfx*nx(i)+cfy*ny(i)
         cfx=0.5*(fm2xl+fm2xr)*area(i)
         cfy=0.5*(fm2yl+fm2yr)*area(i)
         flx(i,3)=cfx*nx(i)+cfy*ny(i)
      enddo

! jump term = lambdaminus*(minus - plus).n
! actually we try to do this like in pp. 505-506 of Giraldo, Hesthaven & Warburton (2002)
! so it's -lambda*(plus-minus)
      do i=1,ntot
         mlx=hl(i)*ul(i) ! Lol reform U
         mrx=hr(i)*ur(i)
         mly=hl(i)*vl(i)
         mry=hr(i)*vr(i)
         ql=abs(ul(i)*nx(i)+vl(i)*ny(i))
!n+=-n-
         qr=abs(-ur(i)*nx(i)-vr(i)*ny(i))
!        q=max(ql,qr) ! CHECK THIS IN LF OF SYSTEMS
!        flx(i,1)=flx(i,1)-0.5*q*(hr(i)-hl(i))*area(i)
         ql=ql+al(i)
         qr=qr+ar(i)
         a=max(ql,qr) ! localest of local Lax-Friedrichses
         flx(i,1)=flx(i,1)-0.5*a*(hr(i)-hl(i))*area(i)
         flx(i,2)=flx(i,2)-0.5*a*(mrx-mlx)*area(i)
         flx(i,3)=flx(i,3)-0.5*a*(mry-mly)*area(i)
      enddo

      return
      end

!-------------------------------------------------------------------------------

      subroutine fill_all_q(fatface)
      include 'SIZE'
      include 'SOLN'
      include 'CMTDATA'

      real fatface(*)
      integer eq,e
      nfq=nx1*nz1*2*ndim*nelt
      nstate = nqq
! where different things live
      iwm =1
      iwp =iwm+nstate*nfq
      iflx=iwp+nstate*nfq

      call fillq(irho,vtrans,fatface(iwm),fatface(iwp))
      call fillq(iux, vx,    fatface(iwm),fatface(iwp))
      call fillq(iuy, vy,    fatface(iwm),fatface(iwp))
!     call fillq(ipr, pr,    fatface(iwm),fatface(iwp))
      call fillq(isnd,csound,fatface(iwm),fatface(iwp))

      return
      end

c-----------------------------------------------------------------------

      subroutine evaluate_entropy_flux(e)
! entropy flux function for entropy residual.
! just vel*s for now
      include 'SIZE'
      include 'SOLN'
      include 'INPUT'
      include 'CMTDATA'
      integer e

      call rzero(totalh,3*nxd*nyd*nzd)
      n=nx1*ny1*nz1

      call col3(totalh(1,1),vx(1,1,1,e),tlag(1,1,1,e,1,1),n)
      call add2col2(totalh(1,1),pr(1,1,1,e),vx(i,1,1,e),n)
      call col3(totalh(1,2),vy(1,1,1,e),tlag(1,1,1,e,1,1),n)
      call add2col2(totalh(1,2),pr(1,1,1,e),vy(i,1,1,e),n)

      return
      end
